阅读call.asm中函数g、f和main的代码。RISC-V的使用手册在参考页上。以下是您应该回答的一些问题（将答案存储在answers-traps.txt文件中）：

    哪些寄存器保存函数的参数？例如，在main对printf的调用中，哪个寄存器保存13？
		a0-a7,    a2
### main的汇编代码中对函数f的调用在哪里？对g的调用在哪里(提示：编译器可能会将函数内联）
	 从printf("%d %d\n", f(8)+1, 13);
  45   24:   4635                    li  a2,13
  46   26:   45b1                    li  a1,12
###	可以看出一整个函数调用链f(g(8))+1都被编译器直接优化成inline了并算出了答案=12, 放置在了a1寄存器里
  
  printf函数位于哪个地址？
###  0000000000000628 <printf>:

    在main中printf的jalr之后的寄存器ra中有什么值？
### 64e:   00000097            auipc   ra,0x0
1113  652:   dce080e7            jalr    -562(ra) # 41c <vprintf>
	首先 0x0左移12位后加上当前指令位置为0x64e
	下面来看jalr (jump and link register)：jalr rd, offset(rs1)跳转并链接寄存器。jalr指令会将当前PC+4保存在rd中，然后跳转到指定的偏移地址offset(rs1)。
	所以首先jalr先将64e+4=652保存在ra中，然后rd0x64e - 562(十进制) = 0x41c 跳转到对应的vprintf函数 


    运行以下代码。
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);

程序的输出是什么？这是将字节映射到字符的ASCII码表。
### HE110 World,57616=0xE110，0x00646c72小端存储为72-6c-64-00，对照ASCII码表
72:r 6c:l 64:d 00:充当字符串结尾标识
因此输出为：HE110 World

输出取决于RISC-V小端存储的事实。如果RISC-V是大端存储，为了得到相同的输出，你会把i设置成什么？是否需要将57616更改为其他值？
### 若为大端存储，i应改为0x726c6400，不需改变57616 

这里有一个小端和大端存储的描述和一个更异想天开的描述。

    在下面的代码中，“y=”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？

printf("x=%d y=%d", 3);
### printf的format字符串在寄存器a0, 3在寄存器a1, 所以当试图print y的时候, 留在寄存器a2的某个随机值就会被print出来
